1.>There are three threads in the userapp, Thread0, Thread1 and Thread2.
2.> A deadlock scenario may occur occasionally based on the order in which the threads are scheduled.
3.> Thread2 first opens a file and exits. Next Thread1 tries to open another file, but since there is a file already opened in mode 1, it’s not able to grab sem2, hence it sleeps. But, it is also to be noted that, although another file is still not opened, the count variable is still incremented as per the driver code. Subsequently, Thread0 gets processed in which there is an ioctl and ioctl will not process a change in mode as count is greater than 1. The files are closed only in the main thread after pthread_join, which doesn’t happen. Hence a deadlock occurs. If threads are scheduled in a different order such that ioctl in Thread0 gets invoked before the open of another file in Thread1, then the mode will change correctly and no deadlock will occur.
